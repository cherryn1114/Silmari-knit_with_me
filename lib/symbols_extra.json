# lib/ingest_youtube.py
# 사용법:
#   python lib/ingest_youtube.py <YouTube URL...>
# 예시:
#   python lib/ingest_youtube.py https://youtube.com/playlist?list=PLexrkqgKCXvC5P6B5Zggyz44M6kAU10P1
# 결과:
#   lib/symbols_extra.json 에 "새로운 용어"만 누적 저장 (개별 영상 링크 1개 포함)

import sys, os, re, json
from pathlib import Path

BASE = Path(__file__).resolve().parent
SYMBOLS_PATH = BASE / "symbols.json"          # 기존 사전(필수)
EXTRA_PATH   = BASE / "symbols_extra.json"    # 새로 수집한 항목 저장(없으면 생성)

def load_json(p: Path) -> dict:
    if not p.exists(): return {}
    with p.open(encoding="utf-8") as f:
        return json.load(f)

def save_json(p: Path, data: dict):
    p.parent.mkdir(parents=True, exist_ok=True)
    with p.open("w", encoding="utf-8") as f:
        json.dump(data, f, ensure_ascii=False, indent=2)

def normalize(s: str) -> str:
    return (s or "").strip().lower()

def fetch_entries(urls):
    """유튜브 URL들(재생목록/단일영상 혼합)을 받아 개별 영상 목록 반환"""
    try:
        import yt_dlp
    except Exception:
        print("❌ yt-dlp가 설치되어 있지 않습니다.  pip install yt-dlp")
        sys.exit(1)

    out = []
    ydl_opts = {"quiet": True, "extract_flat": True, "skip_download": True}
    with yt_dlp.YoutubeDL(ydl_opts) as ydl:
        for raw in urls:
            try:
                info = ydl.extract_info(raw, download=False)
                if info is None:
                    continue
                # playlist/channel vs single video
                entries = info.get("entries") if "entries" in info else [info]
                for e in entries or []:
                    title = (e.get("title") or "").strip()
                    url = e.get("webpage_url") or e.get("url") or ""
                    if url and not url.startswith("http"):
                        url = f"https://www.youtube.com/watch?v={url}"
                    if not (title and url):
                        continue
                    has_ko = bool(re.search(r"[가-힣]", title))
                    out.append({"title": title, "url": url, "lower": title.lower(), "has_ko": has_ko})
            except Exception as ex:
                print(f"⚠️ 읽기 실패: {raw}\n   {ex}")
    # 링크 중복 제거
    uniq = {}
    for v in out:
        uniq[v["url"]] = v
    return list(uniq.values())

def main():
    if len(sys.argv) < 2:
        print("사용법: python lib/ingest_youtube.py <youtube URL...>")
        sys.exit(1)

    urls = sys.argv[1:]
    # 원본/추가 사전 로드
    base = load_json(SYMBOLS_PATH) or {}
    extra = load_json(EXTRA_PATH) or {}

    # 이미 존재하는 "키+별칭"의 인덱스 만들기(중복 방지용)
    known = set()
    def add_known_from(lib: dict):
        for k, v in lib.items():
            known.add(normalize(k))
            for a in v.get("aliases", []):
                known.add(normalize(a))
            # 영문/한글 이름도 중복 키로 간주
            known.add(normalize(v.get("name_en", "")))
            known.add(normalize(v.get("name_ko", "")))
    add_known_from(base)
    add_known_from(extra)

    videos = fetch_entries(urls)
    if not videos:
        print("비디오를 찾지 못했습니다. URL을 확인하세요.")
        sys.exit(0)

    added = 0
    for v in videos:
        title = v["title"]
        url   = v["url"]
        tnorm = normalize(title)

        # 제목이 기존(키/별칭/이름)에 이미 있으면 스킵
        if tnorm in known:
            continue

        # playlist 링크는 제외(요구대로 '개별 영상'만)
        if "list=" in url and "watch?v=" not in url:
            continue

        # 새 항목 구성: title을 키로 사용 (중복 위험 최소화를 위해 그대로 둡니다)
        key = title
        if key in base or key in extra:
            # 키 충돌 시 뒤에 짧은 해시처럼 덧붙임
            key = f"{title} [{abs(hash(title))%10000}]"

        entry = {
            "name_en": title,           # 제목을 그대로 기록 (채널이 한글이면 name_ko에 가깝지만 통일)
            "name_ko": title,
            "desc_ko": "",              # 필요 시 앱 내에서 편집/보강
            "aliases": [title],
            "delta": 0,                 # 기본 0 (증감 정보 모름)
            "videos": [{"title": title, "url": url}]  # 개별 영상 1개
        }

        extra[key] = entry
        # 중복 방지 세트에 추가
        known.add(tnorm)
        known.add(normalize(key))
        added += 1

    save_json(EXTRA_PATH, extra)
    print(f"✅ 새로 추가된 항목: {added}개")
    print(f"→ 저장 위치: {EXTRA_PATH}")

if __name__ == "__main__":
    main()
